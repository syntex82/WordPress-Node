/**
 * Public Controller
 * Handles public-facing routes and renders theme templates
 */

import {
  Controller,
  Get,
  Post,
  Body,
  Param,
  Query,
  Req,
  Res,
  Header,
  UseGuards,
  Inject,
  forwardRef,
  NotFoundException,
} from '@nestjs/common';
import { Request, Response } from 'express';
import { join } from 'path';
import { createReadStream, existsSync } from 'fs';
import { PostsService } from '../content/services/posts.service';
import { PagesService } from '../content/services/pages.service';
import { ThemeRendererService } from '../themes/theme-renderer.service';
import { ProductsService } from '../shop/services/products.service';
import { CategoriesService } from '../shop/services/categories.service';
import { CoursesService } from '../lms/services/courses.service';
import { CertificatesService } from '../lms/services/certificates.service';
import { ProfilesService } from '../users/profiles.service';
import { AuthService } from '../auth/auth.service';
import { RecommendationsService } from '../recommendations/recommendations.service';
import { RecommendationTrackingService } from '../recommendations/recommendation-tracking.service';
import { PrismaService } from '../../database/prisma.service';
import { DevelopersService } from '../marketplace/services/developers.service';
import { MarketplaceService } from '../themes/marketplace.service';
import { PluginMarketplaceService } from '../plugins/plugin-marketplace.service';
import { SubscriptionsService } from '../subscriptions/subscriptions.service';
import { SeoService } from '../seo/seo.service';
import { MediaService } from '../media/media.service';
import { PostStatus } from '@prisma/client';
import { CourseLevel, CoursePriceType } from '../lms/dto/course.dto';
import { OptionalJwtAuthGuard } from '../auth/guards/optional-jwt-auth.guard';

@Controller()
export class PublicController {
  constructor(
    private postsService: PostsService,
    private pagesService: PagesService,
    private themeRenderer: ThemeRendererService,
    private productsService: ProductsService,
    private categoriesService: CategoriesService,
    private coursesService: CoursesService,
    private certificatesService: CertificatesService,
    private profilesService: ProfilesService,
    private authService: AuthService,
    @Inject(forwardRef(() => RecommendationsService))
    private recommendationsService: RecommendationsService,
    @Inject(forwardRef(() => RecommendationTrackingService))
    private trackingService: RecommendationTrackingService,
    private prisma: PrismaService,
    @Inject(forwardRef(() => DevelopersService))
    private developersService: DevelopersService,
    @Inject(forwardRef(() => MarketplaceService))
    private themeMarketplaceService: MarketplaceService,
    @Inject(forwardRef(() => PluginMarketplaceService))
    private pluginMarketplaceService: PluginMarketplaceService,
    @Inject(forwardRef(() => SubscriptionsService))
    private subscriptionsService: SubscriptionsService,
    @Inject(forwardRef(() => SeoService))
    private seoService: SeoService,
    @Inject(forwardRef(() => MediaService))
    private mediaService: MediaService,
  ) {}

  // ==================== SEO ROUTES (must be before catch-all) ====================

  /**
   * Sitemap.xml - Dynamic XML sitemap for search engines
   * GET /sitemap.xml
   */
  @Get('sitemap.xml')
  @Header('Content-Type', 'application/xml')
  async sitemap(@Res() res: Response) {
    const baseUrl = process.env.SITE_URL || 'https://nodepress.co.uk';
    const xml = await this.seoService.generateSitemap(baseUrl);
    res.send(xml);
  }

  /**
   * Robots.txt - Search engine crawling rules
   * GET /robots.txt
   */
  @Get('robots.txt')
  @Header('Content-Type', 'text/plain')
  async robots(@Res() res: Response) {
    const baseUrl = process.env.SITE_URL || 'https://nodepress.co.uk';
    // Override sitemap URL to use root path
    const robotsTxt = `# Robots.txt generated by NodePress CMS
# https://nodepress.co.uk

User-agent: *
Allow: /

# Disallow admin and private paths
Disallow: /admin/
Disallow: /api/
Disallow: /checkout/
Disallow: /login
Disallow: /register
Disallow: /forgot-password
Disallow: /reset-password
Disallow: /my-account
Disallow: /my-courses

# Allow search engines to access these
Allow: /blog/
Allow: /courses/
Allow: /shop/
Allow: /downloads/

# Crawl-delay for polite crawling
Crawl-delay: 1

# Sitemap locations
Sitemap: ${baseUrl}/sitemap.xml
`;
    res.send(robotsTxt);
  }

  /**
   * Optimized Image Endpoint
   * Serves WebP images with responsive sizing and proper caching
   * GET /img/:filename
   */
  @Get('img/:filename')
  async optimizedImage(
    @Param('filename') filename: string,
    @Query('w') width: string,
    @Req() req: Request,
    @Res() res: Response,
  ) {
    try {
      const requestedWidth = width ? parseInt(width, 10) : undefined;
      const supportsWebP = req.headers.accept?.includes('image/webp');

      // Get optimized image path
      const { path: imagePath, contentType } = await this.mediaService.getOptimizedPath(
        filename,
        supportsWebP ? requestedWidth : undefined,
      );

      if (!existsSync(imagePath)) {
        throw new NotFoundException('Image not found');
      }

      // Set cache headers (1 year for immutable assets)
      res.setHeader('Cache-Control', 'public, max-age=31536000, immutable');
      res.setHeader('Content-Type', contentType);
      res.setHeader('Vary', 'Accept');

      // Stream the file
      const stream = createReadStream(imagePath);
      stream.pipe(res);
    } catch (error) {
      // Fall back to original upload path
      const originalPath = join(process.cwd(), 'uploads', filename);
      if (existsSync(originalPath)) {
        res.setHeader('Cache-Control', 'public, max-age=31536000');
        const stream = createReadStream(originalPath);
        stream.pipe(res);
      } else {
        res.status(404).send('Image not found');
      }
    }
  }

  /**
   * RSS Feed - Blog posts feed for content syndication
   * GET /feed.xml or /rss.xml
   */
  @Get('feed.xml')
  @Header('Content-Type', 'application/rss+xml')
  async rssFeed(@Res() res: Response) {
    const baseUrl = process.env.SITE_URL || 'https://nodepress.co.uk';
    const siteName = process.env.SITE_NAME || 'NodePress';

    // Get latest published posts
    const result = await this.postsService.findAll(1, 20, PostStatus.PUBLISHED);
    const posts = result.data;

    const items = posts
      .map(
        (post) => `
    <item>
      <title><![CDATA[${post.title}]]></title>
      <link>${baseUrl}/blog/${post.slug}</link>
      <guid isPermaLink="true">${baseUrl}/blog/${post.slug}</guid>
      <description><![CDATA[${post.metaDescription || post.excerpt || ''}]]></description>
      <pubDate>${new Date(post.publishedAt || post.createdAt).toUTCString()}</pubDate>
      ${post.author ? `<author>${post.author.email} (${post.author.name})</author>` : ''}
    </item>`,
      )
      .join('');

    const rss = `<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>${siteName}</title>
    <link>${baseUrl}</link>
    <description>Latest posts from ${siteName}</description>
    <language>en-us</language>
    <lastBuildDate>${new Date().toUTCString()}</lastBuildDate>
    <atom:link href="${baseUrl}/feed.xml" rel="self" type="application/rss+xml"/>
    ${items}
  </channel>
</rss>`;
    res.send(rss);
  }

  /**
   * Alternate RSS feed path
   * GET /rss.xml
   */
  @Get('rss.xml')
  @Header('Content-Type', 'application/rss+xml')
  async rssXml(@Res() res: Response) {
    return this.rssFeed(res);
  }

  // ==================== ADMIN ROUTES ====================

  /**
   * Admin SPA fallback - serves index.html for /admin route
   * This enables the React app to handle its own routing
   * Must be before the catch-all page route
   */
  @Get('admin')
  async adminSpaRoot(@Res() res: Response) {
    const adminIndexPath = join(process.cwd(), 'admin', 'dist', 'index.html');
    const { existsSync } = await import('fs');

    if (!existsSync(adminIndexPath)) {
      return res.status(503).send(this.getAdminNotBuiltMessage());
    }
    res.sendFile(adminIndexPath);
  }

  /**
   * Admin SPA fallback - serves index.html for all /admin/* routes
   * This enables the React app to handle its own routing
   * Must be before the catch-all page route
   */
  @Get('admin/*')
  async adminSpaFallback(@Res() res: Response) {
    const adminIndexPath = join(process.cwd(), 'admin', 'dist', 'index.html');
    const { existsSync } = await import('fs');

    if (!existsSync(adminIndexPath)) {
      return res.status(503).send(this.getAdminNotBuiltMessage());
    }
    res.sendFile(adminIndexPath);
  }

  /**
   * Returns a helpful error message when admin panel is not built
   */
  private getAdminNotBuiltMessage(): string {
    return `
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Admin Panel Not Built - NodePress CMS</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }
    .container {
      background: white;
      border-radius: 16px;
      padding: 40px;
      max-width: 600px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
    }
    h1 { color: #e53e3e; margin-bottom: 16px; font-size: 24px; }
    p { color: #4a5568; line-height: 1.6; margin-bottom: 16px; }
    .code {
      background: #1a202c;
      color: #68d391;
      padding: 16px;
      border-radius: 8px;
      font-family: 'Consolas', monospace;
      margin: 20px 0;
      overflow-x: auto;
    }
    .code div { margin: 4px 0; }
    .comment { color: #718096; }
    .steps { margin: 20px 0; }
    .steps li { margin: 8px 0; color: #4a5568; }
    .tip {
      background: #ebf8ff;
      border-left: 4px solid #4299e1;
      padding: 12px 16px;
      margin-top: 20px;
      border-radius: 4px;
    }
    .tip strong { color: #2b6cb0; }
  </style>
</head>
<body>
  <div class="container">
    <h1>‚ö†Ô∏è Admin Panel Not Built</h1>
    <p>The admin panel files are missing. This usually happens on a fresh installation.</p>

    <div class="steps">
      <strong>To fix this, run these commands:</strong>
      <div class="code">
        <div><span class="comment"># Navigate to the admin directory</span></div>
        <div>cd admin</div>
        <div></div>
        <div><span class="comment"># Install dependencies</span></div>
        <div>npm install</div>
        <div></div>
        <div><span class="comment"># Build the admin panel</span></div>
        <div>npm run build</div>
        <div></div>
        <div><span class="comment"># Restart the server</span></div>
        <div>cd .. && node dist/main.js</div>
      </div>
    </div>

    <div class="tip">
      <strong>üí° Tip:</strong> If you're using the setup script, make sure it completed without errors.
      Check the console output for any build failures.
    </div>

    <p style="margin-top: 20px; font-size: 14px; color: #718096;">
      After building, refresh this page to access the admin panel.
    </p>
  </div>
</body>
</html>
`;
  }

  /**
   * Home page
   * GET /
   */
  @Get()
  @UseGuards(OptionalJwtAuthGuard)
  async home(@Req() req: Request, @Res() res: Response) {
    try {
      const user = (req as any).user;
      // Fetch posts, featured products, and featured courses in parallel
      const [postsResult, productsResult, categories, coursesResult] = await Promise.all([
        this.postsService.findAll(1, 6, PostStatus.PUBLISHED),
        this.productsService.getActiveProducts({ limit: 8 }),
        this.categoriesService.findAll().catch(() => []),
        this.coursesService.findPublished({ limit: 6 }).catch(() => ({ courses: [] })),
      ]);

      const html = await this.themeRenderer.renderHome(
        postsResult.data,
        {
          featuredProducts: productsResult.products || [],
          categories: categories || [],
          featuredCourses: coursesResult.courses || [],
        },
        user,
      );
      res.send(html);
    } catch (error) {
      console.error('Error rendering home page:', error);
      res.status(500).send(`Error rendering home page: ${error.message}`);
    }
  }

  /**
   * LMS SPA fallback - serves admin panel for all /lms/* routes
   * This enables the React app to handle LMS routing
   * Must be before any catch-all routes
   */
  @Get('lms')
  async lmsRoot(@Res() res: Response) {
    res.redirect('http://localhost:5173/admin/lms');
  }

  @Get('lms/*path')
  async lmsFallback(@Res() res: Response) {
    // In development, redirect to Vite dev server (React app is at /admin/*)
    const originalUrl = res.req?.originalUrl || '/lms';
    res.redirect(`http://localhost:5173/admin${originalUrl}`);
  }

  /**
   * Learn course page - theme rendered learning player
   * GET /learn/:courseId
   */
  @Get('learn/:courseId')
  @UseGuards(OptionalJwtAuthGuard)
  async learnCourse(
    @Req() req: Request,
    @Param('courseId') courseId: string,
    @Res() res: Response,
  ) {
    try {
      const user = (req as any).user;
      const html = await this.themeRenderer.renderLearn(courseId, user);
      res.send(html);
    } catch (error) {
      console.error('Error rendering learn page:', error);
      res.status(500).send(`Error rendering learn page: ${error.message}`);
    }
  }

  /**
   * My Courses page - theme rendered
   * GET /my-courses
   */
  @Get('my-courses')
  @UseGuards(OptionalJwtAuthGuard)
  async myCourses(@Req() req: Request, @Res() res: Response) {
    try {
      const user = (req as any).user;
      const html = await this.themeRenderer.renderMyCourses(user);
      res.send(html);
    } catch (error) {
      console.error('Error rendering my courses page:', error);
      res.status(500).send(`Error rendering my courses page: ${error.message}`);
    }
  }

  /**
   * My Account page - theme rendered
   * GET /my-account
   */
  @Get('my-account')
  @UseGuards(OptionalJwtAuthGuard)
  async myAccount(@Req() req: Request, @Res() res: Response) {
    try {
      const user = (req as any).user;
      const html = await this.themeRenderer.renderMyAccount(user);
      res.send(html);
    } catch (error) {
      console.error('Error rendering my account page:', error);
      res.status(500).send(`Error rendering my account page: ${error.message}`);
    }
  }

  /**
   * Orders page - redirects to my-account orders tab
   * GET /orders
   */
  @Get('orders')
  async ordersPage(@Res() res: Response) {
    res.redirect('/my-account#orders');
  }

  /**
   * Theme Designer page - visual theme customization
   * GET /theme-designer
   */
  @Get('theme-designer')
  @UseGuards(OptionalJwtAuthGuard)
  async themeDesigner(@Req() req: Request, @Res() res: Response) {
    try {
      const user = (req as any).user;
      // Require admin role for theme designer
      if (!user || user.role !== 'ADMIN') {
        return res.redirect('/login?redirect=/theme-designer');
      }
      const html = await this.themeRenderer.renderThemeDesigner(user);
      res.send(html);
    } catch (error) {
      console.error('Error rendering theme designer:', error);
      res.status(500).send(`Error rendering theme designer: ${error.message}`);
    }
  }

  /**
   * Login page
   * GET /login
   */
  @Get('login')
  @UseGuards(OptionalJwtAuthGuard)
  async loginPage(@Req() req: Request, @Query('redirect') redirect: string, @Res() res: Response) {
    try {
      const user = (req as any).user;
      // If already logged in, redirect to home or specified redirect
      if (user) {
        return res.redirect(redirect || '/');
      }
      const html = await this.themeRenderer.renderLogin(redirect);
      res.send(html);
    } catch (error) {
      console.error('Error rendering login page:', error);
      res.status(500).send(`Error rendering login page: ${error.message}`);
    }
  }

  /**
   * Login form submission
   * POST /login
   */
  @Post('login')
  async loginSubmit(
    @Body() body: { email: string; password: string },
    @Query('redirect') redirect: string,
    @Res() res: Response,
  ) {
    try {
      const result = await this.authService.login({ email: body.email, password: body.password });
      // Set JWT as HTTP-only cookie for SSR pages
      res.cookie('access_token', result.access_token, {
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'lax',
        maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days
      });
      res.redirect(redirect || '/');
    } catch (_error) {
      const html = await this.themeRenderer.renderLogin(redirect, 'Invalid email or password');
      res.send(html);
    }
  }

  /**
   * Register page
   * GET /register
   */
  @Get('register')
  @UseGuards(OptionalJwtAuthGuard)
  async registerPage(@Req() req: Request, @Res() res: Response) {
    try {
      const user = (req as any).user;
      // If already logged in, redirect to home
      if (user) {
        return res.redirect('/');
      }
      const html = await this.themeRenderer.renderRegister();
      res.send(html);
    } catch (error) {
      console.error('Error rendering register page:', error);
      res.status(500).send(`Error rendering register page: ${error.message}`);
    }
  }

  /**
   * Register form submission
   * POST /register
   */
  @Post('register')
  async registerSubmit(
    @Body() body: { name: string; email: string; password: string },
    @Res() res: Response,
  ) {
    try {
      await this.authService.register({
        name: body.name,
        email: body.email,
        password: body.password,
      });
      // Auto-login after registration
      const result = await this.authService.login({ email: body.email, password: body.password });
      res.cookie('access_token', result.access_token, {
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'lax',
        maxAge: 7 * 24 * 60 * 60 * 1000,
      });
      res.redirect('/');
    } catch (error) {
      const html = await this.themeRenderer.renderRegister(error.message || 'Registration failed');
      res.send(html);
    }
  }

  /**
   * Logout
   * GET /logout
   */
  @Get('logout')
  async logout(@Res() res: Response) {
    res.clearCookie('access_token');
    res.redirect('/');
  }

  /**
   * Cart page
   * GET /cart
   */
  @Get('cart')
  @UseGuards(OptionalJwtAuthGuard)
  async cartPage(@Req() req: Request, @Res() res: Response) {
    try {
      const user = (req as any).user;
      const html = await this.themeRenderer.renderCart(user);
      res.send(html);
    } catch (error) {
      console.error('Error rendering cart page:', error);
      res.status(500).send(`Error rendering cart page: ${error.message}`);
    }
  }

  /**
   * Checkout page
   * GET /checkout
   */
  @Get('checkout')
  @UseGuards(OptionalJwtAuthGuard)
  async checkoutPage(@Req() req: Request, @Res() res: Response) {
    try {
      const user = (req as any).user;
      const html = await this.themeRenderer.renderCheckout(user);
      res.send(html);
    } catch (error) {
      console.error('Error rendering checkout page:', error);
      res.status(500).send(`Error rendering checkout page: ${error.message}`);
    }
  }

  /**
   * Order success page
   * GET /order-success
   */
  @Get('order-success')
  @UseGuards(OptionalJwtAuthGuard)
  async orderSuccessPage(
    @Req() req: Request,
    @Query('order') orderId: string,
    @Res() res: Response,
  ) {
    try {
      const user = (req as any).user;
      let order: any = null;
      if (orderId) {
        order = await this.prisma.order.findUnique({
          where: { id: orderId },
          include: { items: true },
        });
      }
      const html = await this.themeRenderer.renderOrderSuccess(order, user);
      res.send(html);
    } catch (error) {
      console.error('Error rendering order success page:', error);
      res.status(500).send(`Error rendering order success page: ${error.message}`);
    }
  }

  /**
   * Blog archive
   * GET /blog
   */
  @Get('blog')
  @UseGuards(OptionalJwtAuthGuard)
  async blog(@Req() req: Request, @Query('page') page: string, @Res() res: Response) {
    try {
      const user = (req as any).user;
      const currentPage = page ? parseInt(page) : 1;
      const result = await this.postsService.findAll(currentPage, 10, PostStatus.PUBLISHED);

      const pagination = {
        page: result.meta.page,
        totalPages: result.meta.totalPages,
        hasPrev: result.meta.page > 1,
        hasNext: result.meta.page < result.meta.totalPages,
        prevPage: result.meta.page - 1,
        nextPage: result.meta.page + 1,
      };

      const html = await this.themeRenderer.renderArchive(result.data, pagination, user);
      res.send(html);
    } catch (_error) {
      res.status(500).send('Error rendering blog archive');
    }
  }

  /**
   * Documentation page
   * GET /docs
   */
  @Get('docs')
  @UseGuards(OptionalJwtAuthGuard)
  async docs(@Req() req: Request, @Res() res: Response) {
    try {
      const user = (req as any).user;
      const html = await this.themeRenderer.renderDocs(user);
      res.send(html);
    } catch (error) {
      console.error('Error rendering documentation page:', error);
      res.status(500).send(`Error rendering documentation page: ${error.message}`);
    }
  }

  /**
   * Try Demo page - request a free demo instance
   * GET /try-demo
   */
  @Get('try-demo')
  @UseGuards(OptionalJwtAuthGuard)
  async tryDemo(@Req() req: Request, @Res() res: Response) {
    try {
      const user = (req as any).user;
      const html = await this.themeRenderer.render('try-demo', {
        title: 'Try NodePress Free | 24-Hour Demo',
        description: 'Get instant access to a fully-featured NodePress CMS demo. No credit card required.',
        user,
      });
      res.send(html);
    } catch (error) {
      console.error('Error rendering try-demo page:', error);
      res.status(500).send(`Error rendering try-demo page: ${error.message}`);
    }
  }

  /**
   * Shop page
   * GET /shop
   */
  @Get('shop')
  @UseGuards(OptionalJwtAuthGuard)
  async shop(
    @Req() req: Request,
    @Query('page') page: string,
    @Query('category') category: string,
    @Res() res: Response,
  ) {
    try {
      const user = (req as any).user;
      const currentPage = page ? parseInt(page) : 1;
      const limit = 12;

      // Get categories first (needed to look up categoryId from slug)
      const categories = await this.categoriesService.findAll().catch(() => []);

      // If category slug provided, find the category ID
      let categoryId: string | undefined;
      if (category) {
        const foundCategory = categories.find((c: any) => c.slug === category);
        categoryId = foundCategory?.id;
      }

      const productsResult = await this.productsService.getActiveProducts({
        page: currentPage,
        limit,
        categoryId,
      });

      const pagination = {
        page: currentPage,
        totalPages: productsResult.pagination?.pages || 1,
        hasPrev: currentPage > 1,
        hasNext: currentPage < (productsResult.pagination?.pages || 1),
        prevPage: currentPage - 1,
        nextPage: currentPage + 1,
      };

      const html = await this.themeRenderer.renderShop(
        productsResult.products || [],
        categories || [],
        pagination,
        category || null,
        user,
      );
      res.send(html);
    } catch (error) {
      console.error('Error rendering shop page:', error);
      res.status(500).send(`Error rendering shop page: ${error.message}`);
    }
  }

  /**
   * Single product page
   * GET /shop/product/:slug
   */
  @Get('shop/product/:slug')
  @UseGuards(OptionalJwtAuthGuard)
  async product(@Req() req: Request, @Param('slug') slug: string, @Res() res: Response) {
    try {
      const user = (req as any).user;
      const product = await this.productsService.findBySlug(slug);

      if (!product || product.status !== 'ACTIVE') {
        res.status(404).send('Product not found');
        return;
      }

      // Track this view for recommendations
      await this.trackingService.trackInteraction({
        contentType: 'product',
        contentId: product.id,
        interactionType: 'view',
        userId: user?.id,
        sessionId: req.sessionID,
      });

      // Get related products for recommendations
      const relatedProducts = await this.recommendationsService.getRelatedProducts(
        product.id,
        4,
        user?.id,
      );
      const productWithRecommendations = {
        ...product,
        relatedProducts: relatedProducts.items,
      };

      const html = await this.themeRenderer.renderProduct(productWithRecommendations, user);
      res.send(html);
    } catch (_error) {
      res.status(404).send('Product not found');
    }
  }

  /**
   * Courses catalog
   * GET /courses
   */
  @Get('courses')
  @UseGuards(OptionalJwtAuthGuard)
  async courses(
    @Req() req: Request,
    @Query('page') page: string,
    @Query('category') category: string,
    @Query('level') level: string,
    @Query('priceType') priceType: string,
    @Res() res: Response,
  ) {
    try {
      const user = (req as any).user;
      const currentPage = page ? parseInt(page) : 1;
      const limit = 12;

      const coursesResult = await this.coursesService.findPublished({
        page: currentPage,
        limit,
        category: category || undefined,
        level: level ? (level as CourseLevel) : undefined,
        priceType: priceType ? (priceType as CoursePriceType) : undefined,
      });

      const categoriesList = await this.coursesService.getCategories();

      const pagination = {
        page: currentPage,
        pages: coursesResult.pagination?.pages || 1,
        hasPrev: currentPage > 1,
        hasNext: currentPage < (coursesResult.pagination?.pages || 1),
      };

      const html = await this.themeRenderer.renderCourses(
        coursesResult.courses || [],
        categoriesList.filter((c): c is string => c !== null),
        pagination,
        { category, level, priceType },
        user,
      );
      res.send(html);
    } catch (error) {
      console.error('Error rendering courses page:', error);
      res.status(500).send(`Error rendering courses page: ${error.message}`);
    }
  }

  /**
   * Single course landing page
   * GET /courses/:slug
   */
  @Get('courses/:slug')
  @UseGuards(OptionalJwtAuthGuard)
  async course(@Req() req: Request, @Param('slug') slug: string, @Res() res: Response) {
    try {
      const user = (req as any).user;
      const course = await this.coursesService.findBySlug(slug);

      if (!course || course.status !== 'PUBLISHED') {
        res.status(404).send('Course not found');
        return;
      }

      const html = await this.themeRenderer.renderCourse(course, false, user);
      res.send(html);
    } catch (_error) {
      res.status(404).send('Course not found');
    }
  }

  /**
   * Course enrollment redirect
   * GET /courses/:slug/enroll
   * Redirects to admin app for enrollment process
   */
  @Get('courses/:slug/enroll')
  async enrollCourse(@Param('slug') slug: string, @Res() res: Response) {
    try {
      const course = await this.coursesService.findBySlug(slug);

      if (!course || course.status !== 'PUBLISHED') {
        res.status(404).send('Course not found');
        return;
      }

      // Redirect to the React app for the enrollment flow
      // For free courses, they'll be enrolled directly
      // For paid courses, they'll be redirected to checkout
      res.redirect(`http://localhost:5173/admin/lms/course/${slug}?enroll=true`);
    } catch (_error) {
      res.status(404).send('Course not found');
    }
  }

  /**
   * Certificate verification page
   * GET /verify/:hash
   */
  @Get('verify/:hash')
  async verifyCertificate(@Param('hash') hash: string, @Res() res: Response) {
    try {
      const result = await this.certificatesService.verify(hash);
      const html = await this.themeRenderer.renderCertificateVerify(result);
      res.send(html);
    } catch (_error) {
      res.status(500).send('Error verifying certificate');
    }
  }

  /**
   * Single post
   * GET /post/:slug
   */
  @Get('post/:slug')
  @UseGuards(OptionalJwtAuthGuard)
  async post(@Req() req: Request, @Param('slug') slug: string, @Res() res: Response) {
    try {
      const user = (req as any).user;
      const post = await this.postsService.findBySlug(slug);

      if (post.status !== PostStatus.PUBLISHED) {
        res.status(404).send('Post not found');
        return;
      }

      // Track this view for recommendations
      await this.trackingService.trackInteraction({
        contentType: 'post',
        contentId: post.id,
        interactionType: 'view',
        userId: user?.id,
        sessionId: req.sessionID,
      });

      // Get related posts for recommendations
      const relatedPosts = await this.recommendationsService.getRelatedPosts(post.id, 4, user?.id);
      const postWithRecommendations = {
        ...post,
        relatedPosts: relatedPosts.items,
      };

      const html = await this.themeRenderer.renderPost(postWithRecommendations, user);
      res.send(html);
    } catch (_error) {
      res.status(404).send('Post not found');
    }
  }

  /**
   * User profile page
   * GET /u/:identifier (username or ID)
   */
  @Get('u/:identifier')
  @UseGuards(OptionalJwtAuthGuard)
  async userProfile(
    @Req() req: Request,
    @Param('identifier') identifier: string,
    @Res() res: Response,
  ) {
    try {
      const user = (req as any).user;
      const profile = await this.profilesService.getPublicProfile(identifier);

      if (!profile || !profile.isPublic) {
        res.status(404).send('Profile not found');
        return;
      }

      const stats = await this.profilesService.getStats(profile.id);
      const html = await this.themeRenderer.renderProfile(profile, stats, user);
      res.send(html);
    } catch (error) {
      console.error('Error rendering profile:', error);
      res.status(404).send('Profile not found');
    }
  }

  // ============================================
  // DEVELOPER MARKETPLACE ROUTES
  // ============================================

  /**
   * Hire a Developer page - browse all developers with comprehensive filtering
   * GET /hire-developer
   */
  @Get('hire-developer')
  @UseGuards(OptionalJwtAuthGuard)
  async hireDeveloper(
    @Req() req: Request,
    @Res() res: Response,
    @Query('category') category?: string,
    @Query('skills') skills?: string,
    @Query('minRate') minRate?: string,
    @Query('maxRate') maxRate?: string,
    @Query('search') search?: string,
    @Query('page') page?: string,
    @Query('sortBy') sortBy?: string,
    @Query('experience') experience?: string,
    @Query('availability') availability?: string,
  ) {
    try {
      const user = (req as any).user;
      const currentPage = page ? parseInt(page) : 1;
      const limit = 12;

      // Build experience filter based on years
      let minExperience: number | undefined;
      let maxExperience: number | undefined;
      if (experience === 'entry') {
        minExperience = 0;
        maxExperience = 2;
      } else if (experience === 'mid') {
        minExperience = 3;
        maxExperience = 5;
      } else if (experience === 'senior') {
        minExperience = 6;
        maxExperience = 10;
      } else if (experience === 'expert') {
        minExperience = 10;
      }

      // Get developers with filters
      const result = await this.developersService.findAll({
        status: 'ACTIVE' as any,
        category: category as any,
        skills: skills ? skills.split(',').map((s) => s.trim()) : undefined,
        minRate: minRate ? parseFloat(minRate) : undefined,
        maxRate: maxRate ? parseFloat(maxRate) : undefined,
        availability: availability || undefined,
        search,
        sortBy: sortBy || 'rating',
        page: currentPage,
        limit,
      });

      // Get popular skills for filter suggestions
      const popularSkills = await this.developersService.getAllSkills();

      // Get stats for hero section
      const stats = await this.developersService.getStatistics();

      const categories = [
        { value: 'FRONTEND', label: 'Frontend Developer' },
        { value: 'BACKEND', label: 'Backend Developer' },
        { value: 'FULLSTACK', label: 'Full-Stack Developer' },
        { value: 'CMS', label: 'CMS Developer' },
        { value: 'MOBILE', label: 'Mobile Developer' },
        { value: 'DEVOPS', label: 'DevOps Engineer' },
        { value: 'DESIGN', label: 'UI/UX Designer' },
        { value: 'DATABASE', label: 'Database Expert' },
        { value: 'SECURITY', label: 'Security Specialist' },
      ];

      // Generate pagination pages array for template
      const totalPages = result.pagination.pages || Math.ceil(result.pagination.total / limit);
      const paginationPages = this.generatePaginationPages(currentPage, totalPages);

      const html = await this.themeRenderer.render('hire-developer', {
        title: 'Hire a Developer | Find Top Developers for Your Project',
        developers: result.developers,
        pagination: {
          ...result.pagination,
          page: currentPage,
          totalPages,
        },
        paginationPages,
        categories,
        popularSkills: popularSkills.slice(0, 10),
        stats: {
          totalDevelopers: stats.total || 0,
          projectsCompleted:
            stats.topRated?.reduce((sum: number, d: any) => sum + (d.projectsCompleted || 0), 0) ||
            0,
          avgRating: stats.topRated?.length
            ? (
                stats.topRated.reduce((sum: number, d: any) => sum + (d.rating || 0), 0) /
                stats.topRated.length
              ).toFixed(1)
            : '4.8',
        },
        filters: {
          category,
          skills,
          minRate,
          maxRate,
          search,
          sortBy: sortBy || 'rating',
          experience,
          availability,
        },
        user,
        siteUrl: process.env.SITE_URL || 'https://yoursite.com',
      });
      res.send(html);
    } catch (error) {
      console.error('Error rendering hire-developer page:', error);
      res.status(500).send('Error loading page');
    }
  }

  /**
   * Helper to generate pagination page numbers with ellipsis
   */
  private generatePaginationPages(currentPage: number, totalPages: number): (number | string)[] {
    const pages: (number | string)[] = [];
    const delta = 2;

    for (let i = 1; i <= totalPages; i++) {
      if (i === 1 || i === totalPages || (i >= currentPage - delta && i <= currentPage + delta)) {
        pages.push(i);
      } else if (pages[pages.length - 1] !== '...') {
        pages.push('...');
      }
    }

    return pages;
  }

  /**
   * Developer Marketplace - categorized view
   * GET /developer-marketplace
   */
  @Get('developer-marketplace')
  @UseGuards(OptionalJwtAuthGuard)
  async developerMarketplace(@Req() req: Request, @Res() res: Response) {
    try {
      const user = (req as any).user;

      // Get featured developers
      const featured = await this.developersService.findAll({
        status: 'ACTIVE' as any,
        sortBy: 'rating',
        limit: 6,
      });

      // Get developers by category
      const categories = ['FRONTEND', 'BACKEND', 'FULLSTACK', 'MOBILE', 'DEVOPS', 'DESIGN'];
      const byCategory = await Promise.all(
        categories.map(async (cat) => ({
          category: cat,
          label: cat.charAt(0) + cat.slice(1).toLowerCase().replace('_', ' '),
          developers: (
            await this.developersService.findAll({
              status: 'ACTIVE' as any,
              category: cat as any,
              limit: 4,
            })
          ).developers,
        })),
      );

      const html = await this.themeRenderer.render('developer-marketplace', {
        title: 'Developer Marketplace',
        featured: featured.developers,
        byCategory: byCategory.filter((c) => c.developers.length > 0),
        user,
      });
      res.send(html);
    } catch (error) {
      console.error('Error rendering developer-marketplace:', error);
      res.status(500).send('Error loading page');
    }
  }

  /**
   * Developer Profile page - comprehensive profile with hiring form
   * GET /developer/:slug
   */
  @Get('developer/:slug')
  @UseGuards(OptionalJwtAuthGuard)
  async developerProfile(@Req() req: Request, @Param('slug') slug: string, @Res() res: Response) {
    try {
      const user = (req as any).user;
      const developer = await this.developersService.findBySlug(slug);

      if (!developer) {
        return res.status(404).send('Developer not found');
      }

      // Ensure developer is active (or user is the developer themselves)
      if (developer.status !== 'ACTIVE' && (!user || user.id !== developer.userId)) {
        return res.status(404).send('Developer not found');
      }

      // Get developer reviews if available
      const reviews = await this.developersService.getReviews(developer.id).catch(() => []);

      // Format developer data for template
      const developerData = {
        ...developer,
        reviews: reviews.slice(0, 10), // Limit to 10 reviews
        portfolio: developer.portfolio || [],
        tools: developer.tools || [],
        spokenLanguages: developer.spokenLanguages || [],
        responseTime: developer.responseTime || 24,
        completionRate: developer.completionRate || 95,
      };

      const html = await this.themeRenderer.render('developer-profile', {
        title: `${developer.displayName} - ${developer.headline} | Developer Profile`,
        developer: developerData,
        user,
        siteUrl: process.env.SITE_URL || 'https://yoursite.com',
      });
      res.send(html);
    } catch (error) {
      console.error('Error rendering developer profile:', error);
      res.status(404).send('Developer not found');
    }
  }

  // ============================================
  // THEMES & PLUGINS MARKETPLACE ROUTES
  // ============================================

  /**
   * Marketplace landing page - browse themes and plugins
   * GET /marketplace
   */
  @Get('marketplace')
  @UseGuards(OptionalJwtAuthGuard)
  async marketplace(@Req() req: Request, @Res() res: Response, @Query('tab') tab?: string) {
    try {
      const user = (req as any).user;
      const activeTab = tab === 'plugins' ? 'plugins' : 'themes';

      // Get featured themes and plugins
      const [featuredThemes, featuredPlugins, themeStats, pluginStats] = await Promise.all([
        this.themeMarketplaceService.getFeatured(6),
        this.pluginMarketplaceService.getFeatured(6),
        this.themeMarketplaceService.getStats(),
        this.pluginMarketplaceService.getStats(),
      ]);

      const html = await this.themeRenderer.render('marketplace', {
        title: 'Themes & Plugins Marketplace',
        activeTab,
        featuredThemes,
        featuredPlugins,
        stats: {
          themes: themeStats,
          plugins: pluginStats,
        },
        user,
      });
      res.send(html);
    } catch (error) {
      console.error('Error rendering marketplace:', error);
      res.status(500).send('Error loading marketplace');
    }
  }

  /**
   * Browse themes
   * GET /marketplace/themes
   */
  @Get('marketplace/themes')
  @UseGuards(OptionalJwtAuthGuard)
  async marketplaceThemes(
    @Req() req: Request,
    @Res() res: Response,
    @Query('category') category?: string,
    @Query('search') search?: string,
    @Query('sortBy') sortBy?: string,
    @Query('page') page?: string,
  ) {
    try {
      const user = (req as any).user;

      const [themes, categories] = await Promise.all([
        this.themeMarketplaceService.findAll({
          category,
          search,
          status: 'approved',
          sortBy: (sortBy as any) || 'downloads',
          page: page ? parseInt(page) : 1,
          limit: 12,
        }),
        this.themeMarketplaceService.getCategories(),
      ]);

      const html = await this.themeRenderer.render('marketplace-themes', {
        title: 'Browse Themes',
        themes: themes.themes,
        pagination: themes.pagination,
        categories,
        filters: { category, search, sortBy },
        user,
      });
      res.send(html);
    } catch (error) {
      console.error('Error rendering themes marketplace:', error);
      res.status(500).send('Error loading themes');
    }
  }

  /**
   * Single theme detail page
   * GET /marketplace/themes/:slug
   */
  @Get('marketplace/themes/:slug')
  @UseGuards(OptionalJwtAuthGuard)
  async marketplaceThemeDetail(
    @Req() req: Request,
    @Param('slug') slug: string,
    @Res() res: Response,
  ) {
    try {
      const user = (req as any).user;
      const theme = await this.themeMarketplaceService.findBySlug(slug);

      const html = await this.themeRenderer.render('marketplace-theme-detail', {
        title: theme.name,
        theme,
        user,
      });
      res.send(html);
    } catch (error) {
      console.error('Error rendering theme detail:', error);
      res.status(404).send('Theme not found');
    }
  }

  /**
   * Browse plugins
   * GET /marketplace/plugins
   */
  @Get('marketplace/plugins')
  @UseGuards(OptionalJwtAuthGuard)
  async marketplacePlugins(
    @Req() req: Request,
    @Res() res: Response,
    @Query('category') category?: string,
    @Query('search') search?: string,
    @Query('sortBy') sortBy?: string,
    @Query('page') page?: string,
  ) {
    try {
      const user = (req as any).user;

      const [plugins, categories] = await Promise.all([
        this.pluginMarketplaceService.findAll({
          category,
          search,
          status: 'approved',
          sortBy: (sortBy as any) || 'downloads',
          page: page ? parseInt(page) : 1,
          limit: 12,
        }),
        this.pluginMarketplaceService.getCategories(),
      ]);

      const html = await this.themeRenderer.render('marketplace-plugins', {
        title: 'Browse Plugins',
        plugins: plugins.plugins,
        pagination: plugins.pagination,
        categories,
        filters: { category, search, sortBy },
        user,
      });
      res.send(html);
    } catch (error) {
      console.error('Error rendering plugins marketplace:', error);
      res.status(500).send('Error loading plugins');
    }
  }

  /**
   * Single plugin detail page
   * GET /marketplace/plugins/:slug
   */
  @Get('marketplace/plugins/:slug')
  @UseGuards(OptionalJwtAuthGuard)
  async marketplacePluginDetail(
    @Req() req: Request,
    @Param('slug') slug: string,
    @Res() res: Response,
  ) {
    try {
      const user = (req as any).user;
      const plugin = await this.pluginMarketplaceService.findBySlug(slug);

      const html = await this.themeRenderer.render('marketplace-plugin-detail', {
        title: plugin.name,
        plugin,
        user,
      });
      res.send(html);
    } catch (error) {
      console.error('Error rendering plugin detail:', error);
      res.status(404).send('Plugin not found');
    }
  }

  /**
   * Developer requirements and guidelines page
   * GET /marketplace/developer-guidelines
   */
  @Get('marketplace/developer-guidelines')
  @UseGuards(OptionalJwtAuthGuard)
  async developerGuidelines(@Req() req: Request, @Res() res: Response) {
    try {
      const user = (req as any).user;

      const html = await this.themeRenderer.render('marketplace-guidelines', {
        title: 'Developer Requirements & Guidelines',
        user,
      });
      res.send(html);
    } catch (error) {
      console.error('Error rendering developer guidelines:', error);
      res.status(500).send('Error loading guidelines');
    }
  }

  // ============================================
  // PRICING & SUBSCRIPTION ROUTES
  // ============================================

  /**
   * Pricing page - redirect to admin pricing (requires authentication)
   * GET /pricing
   */
  @Get('pricing')
  @UseGuards(OptionalJwtAuthGuard)
  async pricing(@Req() req: Request, @Res() res: Response) {
    const user = (req as any).user;

    if (user) {
      // Authenticated users go directly to admin pricing
      return res.redirect('/admin/pricing');
    } else {
      // Unauthenticated users go to login with redirect to pricing
      return res.redirect('/login?redirect=/admin/pricing');
    }
  }

  /**
   * Single page
   * GET /:slug
   */
  @Get(':slug')
  @UseGuards(OptionalJwtAuthGuard)
  async page(@Req() req: Request, @Param('slug') slug: string, @Res() res: Response) {
    try {
      const user = (req as any).user;
      const page = await this.pagesService.findBySlug(slug);

      if (page.status !== PostStatus.PUBLISHED) {
        res.status(404).send('Page not found');
        return;
      }

      const html = await this.themeRenderer.renderPage(page, user);
      res.send(html);
    } catch (_error) {
      res.status(404).send('Page not found');
    }
  }
}
